{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Definition of the simulator class\n",
    "\n",
    "In PHYSBO, the simulator class is used to define the objective function.\n",
    "In this section, we will introduce how to define the simulator class based on an example of finding the minimum value of a one-dimensional function.\n",
    "\n",
    "## Defining the search space\n",
    "\n",
    "As in the other tutorials, the first step is to define the search space for the function.\n",
    "In the following example, the search space ``X`` is defined as a grid chopped by ``window_num=10001`` divisions from ``x_min = -2.0`` to ``x_max = 2.0``.\n",
    "Note that ``X`` must be in ``window_num`` x ``d`` ndarray format (``d`` is the number of dimensions, in this case two). In this case, ``d`` is the number of dimensions, in this case two, so we use reshape to transform it."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2020-12-04T06:21:37.552947Z",
     "start_time": "2020-12-04T06:21:37.242727Z"
    }
   },
   "outputs": [],
   "source": [
    "#In\n",
    "import numpy as np\n",
    "import scipy\n",
    "import physbo\n",
    "import itertools\n",
    "\n",
    "#In\n",
    "#Create candidate\n",
    "window_num=10001\n",
    "x_max = 2.0\n",
    "x_min = -2.0\n",
    "\n",
    "X = np.linspace(x_min,x_max,window_num).reshape(window_num, 1)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Defining the simulator class\n",
    "\n",
    "Here, we define the simulator class to set as the objective function.\n",
    "\n",
    "In this case, the problem is to find the minimum $x$ such that $f(x) = 3 x^4 + 4 x ^3 + 1.0$ (the answer is $x=-1.0$).\n",
    "\n",
    "In the simulator class, we define the ``__call__`` function (or ``__init__`` if there are initial variables, etc.).\n",
    "(If there are initial variables, define ``__init__``.) The action indicates the index number of the grid to be retrieved from the search space, and is generally in the form of an ndarray so that multiple candidates can be calculated at once.\n",
    "In this case, we choose one candidate point from ``X`` as ``action_idx=action[0]`` to calculate only one candidate at a time.\n",
    "Since PHYSBO is designed to find the one with the largest objective function value, it returns the value of f(x) at the candidate point multiplied by -1."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2020-12-04T06:21:37.558852Z",
     "start_time": "2020-12-04T06:21:37.554788Z"
    }
   },
   "outputs": [],
   "source": [
    "# Declare the class for calling the simulator.\n",
    "class simulator:\n",
    "\n",
    "    def __call__(self, action ):\n",
    "        action_idx = action[0]\n",
    "        x = X[action_idx][0]\n",
    "        fx = 3.0*x**4 + 4.0*x**3 + 1.0\n",
    "        fx_list.append(fx)\n",
    "        x_list.append(X[action_idx][0])\n",
    "\n",
    "        print (\"*********************\")\n",
    "        print (\"Present optimum interactions\")\n",
    "\n",
    "        print (\"x_opt=\", x_list[np.argmin(np.array(fx_list))])\n",
    "\n",
    "        return -fx, x"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Random Search\n",
    "\n",
    "Before performing Bayesian optimization, prepare training data in advance by randomly selecting candidate points from the search space and evaluating the objective function value."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2020-12-04T06:21:37.717038Z",
     "start_time": "2020-12-04T06:21:37.563144Z"
    }
   },
   "outputs": [],
   "source": [
    "fx_list=[]\n",
    "x_list = []\n",
    "#In\n",
    "# Design of policy\n",
    "# Declaring the policy by\n",
    "policy = physbo.search.discrete.policy(test_X=X)\n",
    "# test_X is the set of candidates which is represented by numpy.array.\n",
    "# Each row vector represents the feature vector of the corresponding candidate\n",
    "\n",
    "# set the seed parameter\n",
    "policy.set_seed( 1 )\n",
    "\n",
    "\n",
    "# If you want to perform the initial random search before starting the Bayesian optimization,\n",
    "# the random sampling is performed by\n",
    "\n",
    "res = policy.random_search(max_num_probes=50, simulator=simulator())\n",
    "# Input:\n",
    "# max_num_probes: number of random search\n",
    "# simulator = simulator\n",
    "# output: combo.search.discreate.results (class)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Performing Bayesian optimization\n",
    "\n",
    "Performs Bayesian optimization on the defined simulator."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2020-12-04T06:24:30.554566Z",
     "start_time": "2020-12-04T06:21:37.718406Z"
    }
   },
   "outputs": [],
   "source": [
    "# single query Bayesian search\n",
    "# The single query version of COMBO is performed by\n",
    "res = policy.bayes_search(max_num_probes= 150, simulator=simulator(), score='TS',\n",
    "                                                  interval=20, num_rand_basis=5000)\n",
    "\n",
    "# Input\n",
    "# max_num_probes: number of searching by Bayesian optimization\n",
    "# simulator: the class of simulator which is defined above\n",
    "# score: the type of aquision funciton. TS, EI and PI are available\n",
    "# interval: the timing for learning the hyper parameter.\n",
    "#               In this case, the hyper parameter is learned at each 20 steps\n",
    "#               If you set the negative value to interval, the hyper parameter learning is not performed\n",
    "#               If you set zero to interval, the hyper parameter learning is performed only at the first step\n",
    "# num_rand_basis: the number of basis function. If you choose 0,  ordinary Gaussian process runs"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Plotting results\n",
    "\n",
    "The results with the best score can be retrieved using ``export_all_sequence_best_fx()``.\n",
    "If you want to see the entire history, you can use ``chosen_actions`` to display it. Here is a sample script to display the results."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2020-12-04T06:24:30.932451Z",
     "start_time": "2020-12-04T06:24:30.555830Z"
    }
   },
   "outputs": [],
   "source": [
    "#In\n",
    "best_fx, best_action = res.export_all_sequence_best_fx()\n",
    "\n",
    "import matplotlib.pyplot as plt\n",
    "# The result of searching is summarized in the class combo.search.discrete.results.history()\n",
    "# res.fx: observed negative energy at each step\n",
    "# res.chosen_actions: history of choosed actions\n",
    "# fbest, best_action= res.export_all_sequence_best_fx(): current best fx and current best action\n",
    "#                                                                                                   that has been observed until each step\n",
    "# res.total_num_search: total number of search\n",
    "plt.plot(res.fx[0:res.total_num_search])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2020-12-04T06:24:31.066401Z",
     "start_time": "2020-12-04T06:24:30.934178Z"
    }
   },
   "outputs": [],
   "source": [
    "plt.plot(best_fx)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2020-12-04T06:24:31.200565Z",
     "start_time": "2020-12-04T06:24:31.068515Z"
    }
   },
   "outputs": [],
   "source": [
    "plt.plot(best_action)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Finally, the candidate with the best score can be displayed as follows. You can see that we have arrived at the correct solution $x=-1$."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2020-12-04T06:24:31.204953Z",
     "start_time": "2020-12-04T06:24:31.201964Z"
    }
   },
   "outputs": [],
   "source": [
    "print(X[int(best_action[-1])])"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.8"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
