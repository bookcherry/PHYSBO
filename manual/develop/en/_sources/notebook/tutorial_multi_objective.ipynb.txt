{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Multi-objective optimization\n",
    "\n",
    "When there are multiple objective functions ($p$) to be optimized, multi-objective optimization is used.  \n",
    "Note that in this tutorial, \"solution\" means the pair of objective functions $y = (y_1(x), y_2(x), \\dots, y_p(x))$.  \n",
    "Define the solution size relation $\\prec$ as follows.  \n",
    "\n",
    "$y \\prec y^{'}\\Longleftrightarrow \\forall \\ i \\le p, y_i \\le y^{'}_i  \\land \\exists \\ j \\le p, y_j < y^{'}_j$ \n",
    "\n",
    "A **Pareto solution** (in the maximization problem) is one in which no solution is larger than itself satisfying the above relations.  \n",
    "In other words, if you try to improve the value of any objective function, one of the other objective functions will deteriorate.  \n",
    "When there is a trade-off between objective functions, there are multiple Pareto solutions, and the numerical task is to find them efficiently.\n",
    "\n",
    "PHYSBO implements a Bayesian optimization method to find Pareto solutions efficiently.  "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-01-05T06:06:13.657438Z",
     "start_time": "2021-01-05T06:06:13.061216Z"
    }
   },
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import physbo\n",
    "%matplotlib inline"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Test functions\n",
    "\n",
    "In this tutorial, we will use VLMOP2, which is a benchmark function for multi-objective optimization.  \n",
    "The number of objective functions is two.\n",
    "\n",
    "$$\n",
    "\\begin{split}\n",
    "    y_1(\\vec{x}) &= 1 - \\exp\\left[-\\sum_{i=1}^N\\left( x_i - 1/\\sqrt{N}\\right)^2\\right] \\\\\n",
    "    y_2(\\vec{x}) &= 1 - \\exp\\left[-\\sum_{i=1}^N\\left( x_i + 1/\\sqrt{N}\\right)^2\\right],\n",
    "\\end{split}\n",
    "$$\n",
    "\n",
    "where $y_1$ and $y_2$ have minimums at $x_1 = x_2 = \\cdots x_N = 1/\\sqrt{N}$ and $x_1 = x_2 = \\cdots x_N = -1/\\sqrt{N}$, respectively, both of which are 0. Also, the upper bound is 1.\n",
    "\n",
    "Since PHYSBO solves a maximization problem, the objective function is again multiplied by -1.\n",
    "\n",
    "- Refernce\n",
    "    - Van Veldhuizen, David A. Multiobjective evolutionary algorithms: classifications, analyses, and new innovations. No. AFIT/DS/ENG/99-01. AIR FORCE INST OF TECH WRIGHT-PATTERSONAFB OH SCHOOL OF ENGINEERING, 1999."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-01-05T06:06:13.662277Z",
     "start_time": "2021-01-05T06:06:13.658957Z"
    }
   },
   "outputs": [],
   "source": [
    "def vlmop2_minus(x):\n",
    "    n = x.shape[1]\n",
    "    y1 = 1 - np.exp(-1 * np.sum((x - 1/np.sqrt(n)) ** 2, axis = 1))\n",
    "    y2 = 1 - np.exp(-1 * np.sum((x + 1/np.sqrt(n)) ** 2, axis = 1))\n",
    "\n",
    "    return np.c_[-y1, -y2]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Preparation of search candidate data\n",
    "\n",
    "Let the input space $\\vec{x}$ be two-dimensional, and generate a grid of candidate points on [-2, 2] Ã— [-2, 2]."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-01-05T06:06:13.676772Z",
     "start_time": "2021-01-05T06:06:13.664110Z"
    }
   },
   "outputs": [],
   "source": [
    "import itertools\n",
    "a = np.linspace(-2,2,101)\n",
    "test_X = np.array(list(itertools.product(a, a)))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-01-05T06:06:13.683329Z",
     "start_time": "2021-01-05T06:06:13.678152Z"
    }
   },
   "outputs": [],
   "source": [
    "test_X"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-01-05T06:06:13.688238Z",
     "start_time": "2021-01-05T06:06:13.684556Z"
    }
   },
   "outputs": [],
   "source": [
    "test_X.shape"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Definition of simulator"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-01-05T06:06:13.693027Z",
     "start_time": "2021-01-05T06:06:13.690029Z"
    }
   },
   "outputs": [],
   "source": [
    "class simulator(object):\n",
    "    def __init__(self, X):\n",
    "        self.t = vlmop2_minus(X)\n",
    "    \n",
    "    def __call__( self, action):\n",
    "        return self.t[action]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-01-05T06:06:13.699166Z",
     "start_time": "2021-01-05T06:06:13.694489Z"
    }
   },
   "outputs": [],
   "source": [
    "simu = simulator(test_X)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Plotting the functions\n",
    "\n",
    "Let's plot each of the two objective functions.  The first objective function has a peak in the upper right corner, and the second objective function has a trade-off with a peak in the lower left corner (The star is the position of the peak.).\n",
    "\n",
    "### First objective function"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-01-05T06:06:13.958020Z",
     "start_time": "2021-01-05T06:06:13.701129Z"
    }
   },
   "outputs": [],
   "source": [
    "plt.figure()\n",
    "plt.imshow(simu.t[:,0].reshape((101,101)), vmin=-1.0, vmax=0.0, origin=\"lower\", extent=[-2.0, 2.0, -2.0, 2.0])\n",
    "plt.title(\"objective 1\")\n",
    "plt.colorbar()\n",
    "plt.plot([1.0/np.sqrt(2.0)], [1.0/np.sqrt(2.0)], '*')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Second objective function"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-01-05T06:06:14.158089Z",
     "start_time": "2021-01-05T06:06:13.960026Z"
    },
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "# plot objective 2\n",
    "plt.figure()\n",
    "plt.imshow(simu.t[:,1].reshape((101,101)), vmin=-1.0, vmax=0.0, origin=\"lower\", extent=[-2.0, 2.0, -2.0, 2.0])\n",
    "plt.title(\"objective 2\")\n",
    "plt.colorbar()\n",
    "plt.plot([-1.0/np.sqrt(2.0)], [-1.0/np.sqrt(2.0)], '*')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Performing optimizations.\n",
    "\n",
    "## Setting policy\n",
    "\n",
    "Use `policy_mo` for multi-objective optimization.  \n",
    "Specify the number of objective functions in `num_objectives`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-01-05T06:06:14.163097Z",
     "start_time": "2021-01-05T06:06:14.159742Z"
    }
   },
   "outputs": [],
   "source": [
    "policy = physbo.search.discrete.policy_mo(test_X=test_X, num_objectives=2)\n",
    "policy.set_seed(0)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "As with the usual usage of `policy` (with one objective function), optimization is done by calling the `random_search` or `bayes_search` methods.  The basic API and usage are roughly the same as `policy`."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Random search"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-01-05T06:06:14.316770Z",
     "start_time": "2021-01-05T06:06:14.164245Z"
    },
    "scrolled": false
   },
   "outputs": [],
   "source": [
    "policy = physbo.search.discrete.policy_mo(test_X=test_X, num_objectives=2)\n",
    "policy.set_seed(0)\n",
    "\n",
    "res_random = policy.random_search(max_num_probes=50, simulator=simu)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The evaluation value of the objective function (the array) and the action ID at that time are displayed.  \n",
    "It also displays a message when the Pareto set is updated.\n",
    "\n",
    "If you want to display the contents of the Pareto set when it is updated, specify `disp_pareto_set=True`.  \n",
    "Pareto set is sorted in ascending order of the first objective function value. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-01-05T06:06:14.493398Z",
     "start_time": "2021-01-05T06:06:14.318132Z"
    },
    "scrolled": false
   },
   "outputs": [],
   "source": [
    "policy = physbo.search.discrete.policy_mo(test_X=test_X, num_objectives=2)\n",
    "policy.set_seed(0)\n",
    "res_random = policy.random_search(max_num_probes=50, simulator=simu, disp_pareto_set=True)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Checking results\n",
    "\n",
    " #### History of evaluation values"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-01-05T06:06:14.498984Z",
     "start_time": "2021-01-05T06:06:14.494679Z"
    },
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "res_random.fx[0:res_random.num_runs]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Obtaining the Pareto solution"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-01-05T06:06:14.504080Z",
     "start_time": "2021-01-05T06:06:14.500385Z"
    }
   },
   "outputs": [],
   "source": [
    "front, front_num = res_random.export_pareto_front()\n",
    "front, front_num"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Plotting the solution (evaluated value)\n",
    "\n",
    "Note again that the space to be plotted is $y = (y_1, y_2)$ and not $x = (x_1, x_2)$.\n",
    "\n",
    "The red plot is the Pareto solution."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-01-05T06:06:14.511086Z",
     "start_time": "2021-01-05T06:06:14.505221Z"
    }
   },
   "outputs": [],
   "source": [
    "def plot_pareto_front(res):\n",
    "    front, front_num = res.export_pareto_front()\n",
    "    dominated = [i for i in range(res.num_runs) if i not in front_num]\n",
    "    points = res.fx[dominated, :]\n",
    "\n",
    "    plt.figure(figsize=(7, 7))\n",
    "    plt.scatter(res.fx[dominated,0], res.fx[dominated,1], c = \"blue\")\n",
    "    plt.scatter(front[:, 0], front[:, 1], c = \"red\")\n",
    "    plt.title('Pareto front')\n",
    "    plt.xlabel('Objective 1')\n",
    "    plt.ylabel('Objective 2')\n",
    "    plt.xlim([-1.0,0.0])\n",
    "    plt.ylim([-1.0,0.0])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-01-05T06:06:14.661288Z",
     "start_time": "2021-01-05T06:06:14.512392Z"
    },
    "scrolled": false
   },
   "outputs": [],
   "source": [
    "plot_pareto_front(res_random)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Calculate the volume of the dominated region\n",
    "\n",
    "A solution that is not a Pareto solution, i.e., a solution $y$ for which there exists a solution $y'$ that is better than itself, is called a subordinate solution ($\\exists y' y\\prec y'$).  The volume of the inferior solution region, which is the space occupied by inferior solutions in the solution space (a subspace of the solution space), is one of the indicators of the results of multi-objective optimization.  The larger this value is, the more good Pareto solutions are obtained.`res_random.pareto.volume_in_dominance(ref_min, ref_max)` calculates the volume of the inferior solution region in the hyper-rectangle specified by `ref_min` and `ref_max`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-01-05T06:06:14.666649Z",
     "start_time": "2021-01-05T06:06:14.662809Z"
    }
   },
   "outputs": [],
   "source": [
    "res_random.pareto.volume_in_dominance([-1,-1],[0,0])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Bayesian optimization\n",
    "\n",
    "For `bayes_search` in the multi-objective case, `score` can be selected from the following method\n",
    "\n",
    "- HVPI (Hypervolume-based Probability of Improvement)\n",
    "- EHVI (Expected Hyper-Volume Improvement)\n",
    "- TS (Thompson Sampling)\n",
    "\n",
    "The following 50 evaluations (10 random searches + 40 Bayesian optimizations) will be performed with different scores."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### HVPI (Hypervolume-based Probability of Improvement)\n",
    "\n",
    "The improvement probability of a non-dominated region in a multi-dimensional objective function space is obtained as a score.  \n",
    "\n",
    "- Reference\n",
    "    - Couckuyt, Ivo, Dirk Deschrijver, and Tom Dhaene. \"Fast calculation of multiobjective probability of improvement and expected improvement criteria for Pareto optimization.\" Journal of Global Optimization 60.3 (2014): 575-594."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-01-05T06:06:29.019463Z",
     "start_time": "2021-01-05T06:06:14.668034Z"
    },
    "scrolled": false
   },
   "outputs": [],
   "source": [
    "policy = physbo.search.discrete.policy_mo(test_X=test_X, num_objectives=2)\n",
    "policy.set_seed(0)\n",
    "\n",
    "policy.random_search(max_num_probes=10, simulator=simu)\n",
    "res_HVPI = policy.bayes_search(max_num_probes=40, simulator=simu, score='HVPI', interval=10)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Plotting the Pareto solution\n",
    "\n",
    "We can see that more Pareto solutions are obtained compared to random sampling."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-01-05T06:06:29.190434Z",
     "start_time": "2021-01-05T06:06:29.020967Z"
    }
   },
   "outputs": [],
   "source": [
    "plot_pareto_front(res_HVPI)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Volume of dominated region"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-01-05T06:06:29.196389Z",
     "start_time": "2021-01-05T06:06:29.191710Z"
    }
   },
   "outputs": [],
   "source": [
    "res_HVPI.pareto.volume_in_dominance([-1,-1],[0,0])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### EHVI (Expected Hyper-Volume Improvement)\n",
    "\n",
    "The expected improvement of the non-dominated region in the multi-dimensional objective function space is obtained as score.  \n",
    "\n",
    "- Reference\n",
    "    - Couckuyt, Ivo, Dirk Deschrijver, and Tom Dhaene. \"Fast calculation of multiobjective probability of improvement and expected improvement criteria for Pareto optimization.\" Journal of Global Optimization 60.3 (2014): 575-594."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-01-05T06:08:41.237335Z",
     "start_time": "2021-01-05T06:06:29.201353Z"
    }
   },
   "outputs": [],
   "source": [
    "policy = physbo.search.discrete.policy_mo(test_X=test_X, num_objectives=2)\n",
    "policy.set_seed(0)\n",
    "\n",
    "policy.random_search(max_num_probes=10, simulator=simu)\n",
    "res_EHVI = policy.bayes_search(max_num_probes=40, simulator=simu, score='EHVI', interval=10)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Plotting the Pareto solution"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-01-05T06:08:41.386473Z",
     "start_time": "2021-01-05T06:08:41.239067Z"
    }
   },
   "outputs": [],
   "source": [
    "plot_pareto_front(res_EHVI)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Volume of dominated region"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-01-05T06:08:41.402348Z",
     "start_time": "2021-01-05T06:08:41.394521Z"
    }
   },
   "outputs": [],
   "source": [
    "res_EHVI.pareto.volume_in_dominance([-1,-1],[0,0])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### TS (Thompson Sampling)\n",
    "\n",
    "In Thompson Sampling for the single objective case, at each candidate (test_X), sampling is performed from the posterior distribution of the objective function, and the candidate with the largest value is recommended as the next search point. In the multi-objective case, one candidate is randomly selected as the next search point from among the candidates with the maximum value based on the Pareto rule for the sampled values, i.e., the Pareto-optimal candidates.\n",
    "\n",
    "- Reference\n",
    "    - Yahyaa, Saba Q., and Bernard Manderick. \"Thompson sampling for multi-objective multi-armed bandits problem.\" Proc. Eur. Symp. Artif. Neural Netw., Comput. Intell. Mach. Learn.. 2015."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-01-05T06:09:52.534284Z",
     "start_time": "2021-01-05T06:08:41.405209Z"
    }
   },
   "outputs": [],
   "source": [
    "policy = physbo.search.discrete.policy_mo(test_X=test_X, num_objectives=2)\n",
    "policy.set_seed(0)\n",
    "\n",
    "policy.random_search(max_num_probes=10, simulator=simu)\n",
    "res_TS = policy.bayes_search(max_num_probes=40, simulator=simu, score='TS', interval=10, num_rand_basis=5000)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Plotting the Pareto solution"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-01-05T06:09:52.716955Z",
     "start_time": "2021-01-05T06:09:52.535519Z"
    }
   },
   "outputs": [],
   "source": [
    "plot_pareto_front(res_TS)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Volume of dominated region"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-01-05T06:09:52.722260Z",
     "start_time": "2021-01-05T06:09:52.718300Z"
    },
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "res_TS.pareto.volume_in_dominance([-1,-1],[0,0])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "code_folding": []
   },
   "source": [
    "## Appendix: Full search\n",
    "\n",
    "In `random_search`, you can easily do a full search by passing the number of all data (`N = test_X.shape[0]`) to `max_num_probes`.  \n",
    "Since it takes time to evaluate all data, reduce the number of data in advance."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-01-05T06:09:53.049904Z",
     "start_time": "2021-01-05T06:09:52.723545Z"
    }
   },
   "outputs": [],
   "source": [
    "test_X_sparse = np.array(list(itertools.product(np.linspace(-2, 2, 21), repeat=2)))\n",
    "simu_sparse = simulator(test_X_sparse)\n",
    "\n",
    "policy = physbo.search.discrete.policy_mo(test_X=test_X_sparse, num_objectives=2)\n",
    "policy.set_seed(0)\n",
    "\n",
    "N = test_X_sparse.shape[0]\n",
    "res_all = policy.random_search(max_num_probes=N, simulator=simu_sparse)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Plotting the Pareto solution"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-01-05T06:09:53.212669Z",
     "start_time": "2021-01-05T06:09:53.051682Z"
    }
   },
   "outputs": [],
   "source": [
    "plot_pareto_front(res_all)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Volume of dominated region"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2021-01-05T06:09:53.218237Z",
     "start_time": "2021-01-05T06:09:53.214184Z"
    }
   },
   "outputs": [],
   "source": [
    "res_all.pareto.volume_in_dominance([-1,-1],[0,0])"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.8"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
