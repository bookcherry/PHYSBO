{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Basic usage of PHYSBO\n",
    "\n",
    "## Introduction\n",
    "\n",
    "In this tutorial, we will introduce how to define the simulator class and find the minimum value of a one-dimensional function using PHYSBO.\n",
    "\n",
    "First, we will import PHYSBO."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2020-12-04T06:02:05.943971Z",
     "start_time": "2020-12-04T06:02:05.507138Z"
    }
   },
   "outputs": [],
   "source": [
    "import physbo"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Defining the search space\n",
    "\n",
    "In the following example, the search space ``X`` is defined as a grid chopped by ``window_num=10001`` divisions from ``x_min = -2.0`` to ``x_max = 2.0``.\n",
    "Note that ``X`` must be in ``window_num`` x ``d`` ndarray format (``d`` is the number of dimensions, in this case one). In this case, ``d`` is the number of dimensions, in this case two, so we use reshape to transform it."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2020-12-04T06:02:05.950047Z",
     "start_time": "2020-12-04T06:02:05.945622Z"
    }
   },
   "outputs": [],
   "source": [
    "#In\n",
    "import numpy as np\n",
    "import scipy\n",
    "import physbo\n",
    "import itertools\n",
    "\n",
    "#In\n",
    "#Create candidate\n",
    "window_num=10001\n",
    "x_max = 2.0\n",
    "x_min = -2.0\n",
    "\n",
    "X = np.linspace(x_min,x_max,window_num).reshape(window_num, 1)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Defining the simulator class\n",
    "\n",
    "Here, we define the simulator class to set as the objective function.\n",
    "\n",
    "In this case, the problem is to find the minimum $x$ such that $f(x) = 3 x^4 + 4 x ^3 + 1.0$ (the answer is $x=-1.0$).\n",
    "\n",
    "In the simulator class, we define the ``__call__`` function (or ``__init__`` if there are initial variables, etc.).\n",
    "(If there are initial variables, define ``__init__``.) The action indicates the index number of the grid to be retrieved from the search space, and is generally in the form of an ndarray so that multiple candidates can be calculated at once.\n",
    "In this case, we choose one candidate point from ``X`` as ``action_idx=action[0]`` to calculate only one candidate at a time.\n",
    "Since **PHYSBO is designed to find the maximum value of the objective function**, it returns the value of f(x) at the candidate point multiplied by -1."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2020-12-04T06:02:06.115603Z",
     "start_time": "2020-12-04T06:02:06.107365Z"
    }
   },
   "outputs": [],
   "source": [
    "# Declare the class for calling the simulator.\n",
    "class simulator:\n",
    "\n",
    "    def __call__(self, action ):\n",
    "        action_idx = action[0]\n",
    "        x = X[action_idx][0]\n",
    "        fx = 3.0*x**4 + 4.0*x**3 + 1.0\n",
    "        fx_list.append(fx)\n",
    "        x_list.append(X[action_idx][0])\n",
    "\n",
    "        print (\"*********************\")\n",
    "        print (\"Present optimum interactions\")\n",
    "\n",
    "        print (\"x_opt=\", x_list[np.argmin(np.array(fx_list))])\n",
    "\n",
    "        return -fx, x"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Performing optimization"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Setting policy\n",
    "\n",
    "First, set the optimization `policy`.  \n",
    "\n",
    "Next, set `test_X` to the matrix of search candidates (`numpy.array`)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2020-12-04T06:02:06.149593Z",
     "start_time": "2020-12-04T06:02:06.143075Z"
    }
   },
   "outputs": [],
   "source": [
    "# set policy \n",
    "policy = physbo.search.discrete.policy(test_X=X)\n",
    "\n",
    "# set seed\n",
    "policy.set_seed(0)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "When `policy` is set, no optimization is done yet.\n",
    "Execute the following methods on `policy` to optimize it.\n",
    "\n",
    "- `random_search`.  \n",
    "- `bayes_search`.\n",
    "\n",
    "If you specify the `simulator` and the number of search steps in these methods, the following loop will be executed for the number of search steps.\n",
    "\n",
    "i) Select the next parameter to be executed from the candidate parameters.\n",
    "\n",
    "ii) Execute `simulator` with the selected parameters.\n",
    "\n",
    "The default number of parameter returned by i) is one, but it is possible to return multiple parameters in one step.\n",
    "See the section \"Searching for multiple candidates at once\" for details.  \n",
    "\n",
    "Also, instead of running the above loop inside PHYSBO, it is possible to control i) and ii) separately from the outside. In other words, it is possible to propose the next parameter to be executed from PHYSBO, evaluate its objective function value in some way outside PHYBO (e.g., by experiment rather than numerical calculation), propose it in some way outside PHYSBO, and register the evaluated value in PHYSBO. For more details, please refer to the \"Running Interactively\" section of the tutorial.\n",
    "\n",
    "### Random Search\n",
    "\n",
    "First of all, let's perform a random search.\n",
    "\n",
    "Since Bayesian optimization requires at least two objective function values to be obtained (the initial number of data required depends on the problem to be optimized and the dimension d of the parameters), we will first perform a random search.   \n",
    "\n",
    "**argument**.  \n",
    "\n",
    "- `max_num_probes`: Number of search steps.  \n",
    "- `simulator`: The simulator of the objective function (an object of class simulator). "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2020-12-04T06:02:06.380266Z",
     "start_time": "2020-12-04T06:02:06.154735Z"
    },
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "fx_list=[]\n",
    "x_list = []\n",
    "\n",
    "res = policy.random_search(max_num_probes=20, simulator=simulator())"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "When executed, the objective function value and its action ID for each step, and the best value up to now and its action ID will be printed as follows.\n",
    "\n",
    "````\n",
    "0020-th step: f(x) = -19.075990 (action=8288)\n",
    "   current best f(x) = -0.150313 (best action=2949) \n",
    "````\n",
    "\n",
    "\n",
    "### Bayesian Optimization\n",
    "\n",
    "Next, we run the Bayesian optimization as follows.\n",
    "\n",
    "**argument**.  \n",
    "\n",
    "- `max_num_probes`: Number of search steps.  \n",
    "- `simulator`: The simulator of the objective function (an object of class simulator).  \n",
    "- `score`: The type of acquisition function. You can specify one of the following\n",
    "    - TS (Thompson Sampling)  \n",
    "    - EI (Expected Improvement)  \n",
    "    - PI (Probability of Improvement)  \n",
    "- `interval`:  \n",
    "The hyperparameters are trained at the specified interval.  \n",
    "If a negative value is specified, no hyperparameter will be learned.  \n",
    "0 means that hyperparameter learning will be performed only in the first step.  \n",
    "- `num_rand_basis`: Number of basis functions. 0 means that a normal Gaussian process without Bayesian linear model will be used.  "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2020-12-04T06:03:19.374318Z",
     "start_time": "2020-12-04T06:02:06.382690Z"
    },
    "code_folding": [],
    "scrolled": false
   },
   "outputs": [],
   "source": [
    "res = policy.bayes_search(max_num_probes=200, simulator=simulator(), score='TS', \n",
    "                                                  interval=20, num_rand_basis=5000)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Checking the results\n",
    "\n",
    "The search result ``res`` is returned as an object of the ``history`` class (`physbo.search.discrete.results.history`).  \n",
    "The following is a reference to the search results.\n",
    "\n",
    "- `res.fx` : The history of evaluated values of simulator (objective function).\n",
    "- `res.chosen_actions`: The history of action IDs (parameters) when the simulator was evaluated.  \n",
    "- `fbest, best_action= res.export_all_sequence_best_fx()`: The history of best values and their action IDs (parameters) for all timings when the simulator was evaluated.\n",
    "- `res.total_num_search`: Total number of simulator evaluations.\n",
    "\n",
    "Let's plot the objective function value and the best value at each step.  \n",
    "`res.fx` and `best_fx` should range up to `res.total_num_search`, respectively."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2020-12-04T06:03:19.620065Z",
     "start_time": "2020-12-04T06:03:19.375626Z"
    }
   },
   "outputs": [],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "%matplotlib inline"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2020-12-04T06:03:19.774131Z",
     "start_time": "2020-12-04T06:03:19.621947Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[<matplotlib.lines.Line2D at 0x13b1822d0>]"
      ]
     },
     "execution_count": 8,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "plt.plot(res.fx[0:res.total_num_search])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2020-12-04T06:03:19.873280Z",
     "start_time": "2020-12-04T06:03:19.775506Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[<matplotlib.lines.Line2D at 0x13b3e3dd0>]"
      ]
     },
     "execution_count": 9,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "best_fx, best_action = res.export_all_sequence_best_fx()\n",
    "plt.plot(best_fx)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Serializing the results\n",
    "\n",
    "The search results can be saved to an external file using the `save` method."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2020-12-04T06:03:19.880149Z",
     "start_time": "2020-12-04T06:03:19.874622Z"
    }
   },
   "outputs": [],
   "source": [
    "res.save('search_result.npz')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2020-12-04T06:03:19.883409Z",
     "start_time": "2020-12-04T06:03:19.881419Z"
    }
   },
   "outputs": [],
   "source": [
    "del res"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Load the saved result file as follows:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {
    "ExecuteTime": {
     "end_time": "2020-12-04T06:03:19.892245Z",
     "start_time": "2020-12-04T06:03:19.884981Z"
    }
   },
   "outputs": [],
   "source": [
    "res = physbo.search.discrete.results.history()\n",
    "res.load('search_result.npz')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Finally, the candidate with the best score can be displayed as follows. You can see that we have arrived at the correct solution $x=-1$."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "print(X[int(best_action[-1])])"
   ]
  }
 ],
 "metadata": {
  "anaconda-cloud": {},
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.8"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
